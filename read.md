/* Gradle Code
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds/
 */
buildscript {
    repositories {
        maven {
            url 'https://repo1.uhc.com/artifactory/repoauth'
            credentials {
//                username = System.getenv("DOCKER_USERNAME")
//                password = System.getenv("DOCKER_PASSWORD")
                username = "runx_ohhlload";
                password = "ohLOA35U";
            }
        }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:2.7.20.optum-2")
        classpath("io.spring.gradle:dependency-management-plugin:1.0.15.RELEASE")
    }
}

/// Method to get the current git branch
def gitBranch() {
    def branch = ""
    def proc = "git describe --all".execute()
    proc.in.eachLine { line -> branch = line }
    proc.err.eachLine { line -> println line }
    proc.waitFor()
    branch
}

print gitBranch()

if (gitBranch().equals("heads/master") || gitBranch().equals("remotes/origin/master")) {
    project.version = '2.0-SNAPSHOT'
} else {
    project.version = '1.0-SNAPSHOT'
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'io.spring.dependency-management'

repositories {
    maven {
        url 'https://repo1.uhc.com/artifactory/repoauth'
        credentials {
//            username = System.getenv("DOCKER_USERNAME")
//            password = System.getenv("DOCKER_PASSWORD")
            username = "runx_ohhlload";
            password = "ohLOA35U";
        }
    }
    maven {
        url 'https://repo1.uhc.com/artifactory/libs-releases/'
    }
}



sourceCompatibility = 1.8
targetCompatibility = 1.8

dependencyManagement {
    imports {
        mavenBom 'com.amazonaws:aws-java-sdk-bom:1.12.734'
    }
}

dependencies {
    annotationProcessor "org.projectlombok:lombok:1.18.22"
    implementation 'com.amazonaws:aws-java-sdk-s3:1.12.734'
    implementation 'org.apache.logging.log4j:log4j-api:2.17.1'
    implementation 'org.apache.logging.log4j:log4j-core:2.17.1'
    // https://mvnrepository.com/artifact/javax.json/javax.json-api
    implementation group: 'javax.json', name: 'javax.json-api', version: '1.0-b01'
    // https://mvnrepository.com/artifact/com.google.code.gson/gson
    implementation group: 'com.google.code.gson', name: 'gson',version: '2.9.1'
    implementation group: 'org.glassfish', name: 'javax.json', version: '1.1'
    // https://mvnrepository.com/artifact/org.elasticsearch.client/elasticsearch-rest-high-level-client
    implementation 'org.elasticsearch.client:elasticsearch-rest-high-level-client:7.17.15'
    //JMockit dependencies
    testImplementation group: 'org.jmockit', name: 'jmockit', version: '1.19'
    //JUnit dependencies
    testImplementation 'junit:junit:4.13.2'
    // https://mvnrepository.com/artifact/org.json/json
    implementation group: 'org.json', name: 'json', version: '20231013'
    // https://mvnrepository.com/artifact/org.projectlombok/lombok
    implementation group: 'org.projectlombok', name: 'lombok', version: '1.18.22'
    // https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations
    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-annotations',version:'2.16.2'
    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-core',version:'2.16.2'
    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind',version:'2.16.2'
    // https://mvnrepository.com/artifact/org.powermock/powermock-api-mockito
    testImplementation group: 'org.powermock', name: 'powermock-api-mockito', version: '1.6.5'
    // https://mvnrepository.com/artifact/org.powermock/powermock-module-junit4
    testImplementation group: 'org.powermock', name: 'powermock-module-junit4', version: '1.6.5'
    // https://mvnrepository.com/artifact/org.mockito/mockito-core
    testImplementation group: 'org.mockito', name: 'mockito-core', version: '1.10.19'
    // https://mvnrepository.com/artifact/commons-io/commons-io
    implementation group: 'commons-io', name: 'commons-io', version: '2.8'
    implementation group: 'org.yaml', name:'snakeyaml', version:'2.0'
    // https://mvnrepository.com/artifact/javax.ws.rs/javax.ws.rs-api
    implementation group: 'javax.ws.rs', name: 'javax.ws.rs-api',version: '2.1'
}

**ConfigurationManager.java**
package com.optum.pure.common;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * Fetches the Configuration from config.properties file
 *
 * @author Dwarakesh T P
 */
public class ConfigurationManager {

    private static final Logger LOG = LogManager.getLogger(ConfigurationManager.class);
    private static Properties props;

    static {
        props = new Properties();
        ClassLoader cLoader = Thread.currentThread().getContextClassLoader();
        try (InputStream stream = cLoader.getResourceAsStream("config.properties")) {
            props.clear();
            props.load(stream);
            props.putAll(System.getenv());
            LOG.debug("Configuration Properties loaded successfully");
        } catch (IOException e) {
            LOG.error("Configuration Properties failed to load", e);
        }
    }

    private ConfigurationManager() {
    }

    public static String get(String key) {
        return props.getProperty(key);
    }
}

**RestElasticSearchClient.java**

package com.optum.pure.common;

import org.apache.http.Header;
import org.apache.http.HttpHeaders;
import org.apache.http.HttpHost;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.client.CredentialsProvider;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.message.BasicHeader;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.client.RestHighLevelClientBuilder;

import javax.ws.rs.core.MediaType;

/**
 * RestElasticsearchClient is used to get RestHighLevel client for connecting to elasticsearch.
 *
 * @author Nandu
 */

public class RestElasticsearchClient {

    private static final String ES_HOSTNAME = ConfigurationManager.get("ES_HOSTNAME");
    private static final String ES_PORT = ConfigurationManager.get("ES_PORT");
    private static final String ES_SCHEME = ConfigurationManager.get("ES_SCHEME");
    private static final String ES_USERNAME = ConfigurationManager.get("ES_USERNAME");
    private static final String ES_PASSWORD = ConfigurationManager.get("ES_PASSWORD");
    private static RestHighLevelClient client = getClient(ES_HOSTNAME, Integer.parseInt(ES_PORT), ES_SCHEME, ES_USERNAME,
            ES_PASSWORD);

    private RestElasticsearchClient() {
    }

    private static RestHighLevelClient getClient(final String hostname, final int port, final String scheme,
                                                 final String username, final String password) {
        Header[] headers = {new BasicHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON),
                new BasicHeader("Role", "Read")};
        final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password));
        //set compatibility with ES 8.x https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-compatibility.html
        return new RestHighLevelClientBuilder(RestClient.builder(new HttpHost(hostname, port, scheme))
                .setDefaultHeaders(headers).setHttpClientConfigCallback(
                        httpClientBuilder -> httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider))
                .build())
                .setApiCompatibilityMode(true)
                .build();
    }

    public static RestHighLevelClient getClient() {
        return client;
    }
}

**StatusEnum.java**
package com.optum.pure.common;

/**
 * Enums for Response status
 */
public enum StatusEnum {
    NOT_YET_STARTED,
    INVALID,
    IN_PROGRESS,
    COMPLETED_SUCCESSFULLY,
    ERRORED
}

**Utils.java**
package com.optum.pure.common;

import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3Client;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.List;
import java.util.UUID;

/**
 * Generic Util class
 */
public final class Utils {

    public static final String FILE_SEPARATOR = "/";
    public static final String TRACKING_ID = "trackingId";
    public static final String VERSION = "version";
    public static final String INPUT_ARTIFACT_URI = "inputArtifactUri";
    public static final String VER_V1 = "v1";
    public static final String VER_V2 = "v2";
    /**
     * TODO
     * Maximum no of records returned from the store,
     * if there is a member with more than the MAX_RECORDS
     * then it will not return all the values.
     */
    public static final int MAX_RECORDS = 10000;
    private static final Logger LOG = LogManager.getLogger(Utils.class);
    private static AmazonS3 s3Client = null;

    private Utils() {
    }

    /**
     * Generate tracking id
     *
     * @return
     */
    public static String generateTrackingId() {
        return UUID.randomUUID().toString();
    }

    /**
     * Returns the current date in "yyyy-MM-dd" format
     *
     * @return
     */
    public static String getCurrentDate() {
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        Date date = new Date();
        return dateFormat.format(date);
    }

    /**
     * Returns the current timestamp in yyyy-MM-dd HH:mm:ss format
     *
     * @return
     */
    public static String getCurrentTimestamp() {
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
    }

    /**
     * Returns the Kafka resource path
     *
     * @return
     */
    public static String getKafkaResourcePath() {
        return "src" + Utils.FILE_SEPARATOR + "main" + Utils.FILE_SEPARATOR + "resources" + Utils.FILE_SEPARATOR;
    }

    /**
     * This method is to validate String fields in POJO and to remove fields with null/none/empty values.
     *
     * @param value The field value to be validated
     * @return null if validation fails, else value itself.
     */
    public static String stringFieldValidator(String value) {
        if (value == null || value.equalsIgnoreCase("null") || value.equalsIgnoreCase("none") || value.isEmpty()) {
            return null;
        }
        return value;
    }

    /**
     * This method is to validate List fields in POJO and to remove fields with null/empty values.
     *
     * @param value The field value to be validated
     * @return null if validation fails, else value itself.
     */
    public static <T> List<T> listFieldValidator(List<T> value) {
        if (value == null || value.isEmpty()) {
            return null;
        }
        return value;
    }

    /**
     * Returns the OOSS inputArtifact URI
     *
     * @return
     */
    public static String getNewInputArtifactUri(String trackingId) {
        return frameUri(trackingId, "input");
    }

    /**
     * Returns the OOSS outputArtifact URI
     *
     * @return
     */
    public static String getNewOutputArtifactUri(String trackingId) {
        return frameUriGzip(trackingId, "output");
    }

    /**
     * Method to construct the URI
     *
     * @param trackingId
     * @param context
     * @return
     */
    private static String frameUri(String trackingId, String context) {
        return context + Utils.FILE_SEPARATOR + Utils.getCurrentDate() + Utils.FILE_SEPARATOR + trackingId + ".json";
    }

    private static String frameUriGzip(String trackingId, String context) {
        return context + Utils.FILE_SEPARATOR + Utils.getCurrentDate() + Utils.FILE_SEPARATOR + trackingId + ".gz";
    }

    /**
     * Creates a new AmazonS3 client based on the configuration values
     *
     * @return
     */
    private static AmazonS3 createS3client() {
        //TODO - Replace deprecated AmazonS3Client
        String serviceEndPoint = ConfigurationManager.get("OOSS_URL");
        BasicAWSCredentials credentials = new BasicAWSCredentials(ConfigurationManager.get("OOSS_ACCESS_KEY"),
                ConfigurationManager.get("OOSS_SECRET_KEY"));
        AmazonS3 amazonS3Client = new AmazonS3Client(credentials);
        amazonS3Client.setEndpoint(serviceEndPoint);

        return amazonS3Client;
    }

    /**
     * Returns AmazonS3 client, which is further used in performing IO operations with OOSS
     *
     * @return
     */
    public synchronized static AmazonS3 getS3client() {
        if (s3Client == null) {
            s3Client = createS3client();
        }
        LOG.info("OOSS - Connection successful");
        return s3Client;
    }
}

**FileStoreFactory.java**

package com.optum.pure.filestore.factory;

import com.optum.pure.filestore.FileStore;
import com.optum.pure.filestore.impl.OOSSFileStore;

/**
 * Factory class for File store
 *
 * @author Dwarakesh T P
 */
public class FileStoreFactory {

    private static FileStore fileStore;

    private FileStoreFactory() {
    }

    public static synchronized FileStore getFileStore() {
        if (fileStore == null)
            fileStore = new OOSSFileStore();
        return fileStore;
    }
}
**OOSSFileStore.java**

package com.optum.pure.filestore.impl;

import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3Client;
import com.amazonaws.services.s3.model.ObjectMetadata;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.services.s3.model.S3ObjectInputStream;
import com.amazonaws.services.s3.transfer.TransferManager;
import com.amazonaws.services.s3.transfer.TransferManagerBuilder;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.optum.pure.common.ConfigurationManager;
import com.optum.pure.common.Utils;
import com.optum.pure.filestore.FileStore;
import org.apache.commons.io.IOUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.zip.GZIPOutputStream;

/**
 * Implementation class for OOSS Filestore
 *
 * @author Dwarakesh T P
 */
public class OOSSFileStore implements FileStore {

    private static final Logger LOG = LogManager.getLogger(OOSSFileStore.class);
    private final TransferManager transferManager = TransferManagerBuilder
            .standard()
            .withS3Client(Utils.getS3client())
            .build();
    private String bucketName = ConfigurationManager.get("OOSS_BUCKET");

    /**
     * Checks for the existence of object in OOSS, return true if present, else returns false
     *
     * @param s3Client
     * @param objectName
     * @return
     */
    public boolean checkIfObjectPresent(AmazonS3 s3Client, String objectName) {
        return s3Client.doesObjectExist(bucketName, objectName);
    }

    /**
     * Reads the specific file from OOSS and returns the retrieved data in the form of a POJO
     *
     * @param objectKey - ArtifactUri
     * @return -
     */
    public byte[] readObject(String objectKey) throws IOException {
        byte[] resultObject;
        S3Object object;
        AmazonS3 s3Client = Utils.getS3client();
        LOG.debug("Reading Object with ObjectKey {} from OOSS", objectKey);
        boolean isObjectPresent = checkIfObjectPresent(s3Client, objectKey);
        if (!isObjectPresent) {
            LOG.error("ObjectKey {} not found in bucket {}", objectKey, bucketName);
            throw new FileNotFoundException(objectKey);
        }
        try {
            object = s3Client.getObject(bucketName, objectKey);
            LOG.info("Object - {} successfully retrieved from OOSS bucket - {}", objectKey, bucketName);
        } catch (Exception e) {
            LOG.error("Failed to read ObjectKey {} from OOSS bucket - {}", objectKey, bucketName);
            throw e;
        }
        LOG.debug("{} - {}", objectKey, true);
        S3ObjectInputStream ipStream = object.getObjectContent();
        resultObject = IOUtils.toByteArray(ipStream);
        LOG.debug("resultObject successfully extracted from S3InputStream, object key -> {}", objectKey);
        return resultObject;
    }

    /**
     * Converts the Object data into a json, writes it to a file and the persist the json file in the OOSS
     *
     * @param objectKey - AritifactUri
     * @param data      - Data to be written to the FileStore
     */
    private void writeObject(String objectKey, Object data) throws JsonProcessingException, InterruptedException {
        try {
            byte[] bytesToWrite = new ObjectMapper().writeValueAsBytes(data);
            ObjectMetadata metaData = new ObjectMetadata();
            metaData.setContentLength(bytesToWrite.length);
            transferManager.upload(bucketName,
                    objectKey,
                    new ByteArrayInputStream(bytesToWrite),
                    metaData).waitForCompletion();
            LOG.info("ObjectKey - {} successfully uploaded to OOSS bucket - {}", objectKey, bucketName);
        } catch (Exception e) {
            LOG.error("Upload of ObjectKey - {} to OOSS bucket - {} Failed", objectKey, bucketName);
            throw e;
        }
    }

    /**
     * Converts the Object data into a json, writes it to a file and the persist the json file in the OOSS
     *
     * @param objectKey            - AritifactUri
     * @param data                 - Data to be written to the FileStore
     * @param isCompressionEnabled - Flag to enable/disable compression
     */
    public void writeObject(String objectKey, Object data, boolean isCompressionEnabled) throws IOException, InterruptedException {
        if (isCompressionEnabled) {
            try {
                byte[] bytesToWrite = new ObjectMapper().writeValueAsBytes(data);
                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                GZIPOutputStream outputStream = new GZIPOutputStream(byteArrayOutputStream);
                outputStream.write(bytesToWrite, 0, bytesToWrite.length);
                outputStream.finish();
                outputStream.close();
                bytesToWrite = byteArrayOutputStream.toByteArray();
                ObjectMetadata metaData = new ObjectMetadata();
                metaData.setContentLength(bytesToWrite.length);
                transferManager.upload(bucketName, objectKey, new ByteArrayInputStream(bytesToWrite), metaData)
                        .waitForCompletion();
                LOG.info("ObjectKey - {} successfully uploaded to OOSS bucket - {}", objectKey, bucketName);
            } catch (Exception e) {
                LOG.error("Upload of ObjectKey - {} to OOSS bucket - {} Failed", objectKey, bucketName);
                throw e;
            }
        } else {
            writeObject(objectKey, data);
        }
    }

    /**
     * Deletes the specific file from OOSS, if exists.
     * Returns true if the file is successfully deleted from OOSS else returns false
     *
     * @param oossFolder
     * @param objectName
     * @return
     */
    public boolean deleteObject(String oossFolder, String objectName) {
        AmazonS3 s3Client = Utils.getS3client();
        String objectKey = oossFolder + Utils.FILE_SEPARATOR + objectName;
        boolean isObjectedDeleted = false;
        try {
            s3Client.deleteObject(bucketName, objectKey);
            isObjectedDeleted = true;
            LOG.debug("{} successfully deleted from OOSS - {}", objectName, oossFolder);
        } catch (Exception e) {
            LOG.error("OOSS Delete operation failed for object - {}, bucket - {}", objectName, bucketName);
            throw e;
        }
        return isObjectedDeleted;
    }
}

**FileStory.java**
package com.optum.pure.filestore;

import com.amazonaws.services.s3.AmazonS3;

import java.io.IOException;

/**
 * Interface for File store
 *
 * @author Dwarakesh T P
 */
public interface FileStore {
    /**
     * Check if object is present in the store or not.
     *
     * @param objectName - object key
     * @return - boolean value indicating whether object is found or not
     */
    boolean checkIfObjectPresent(AmazonS3 s3client, String objectName);

    /**
     * Method to read OOSS object
     *
     * @param artifactUri
     * @return
     * @throws IOException
     */
    byte[] readObject(String artifactUri) throws IOException;

    /**
     * Method to write object
     *
     * @param artifactUri
     * @param data
     * @param isCompressionEnabled
     * @throws IOException
     * @throws InterruptedException
     */
    void writeObject(String artifactUri, Object data, boolean isCompressionEnabled) throws InterruptedException, IOException;

    /**
     * Delete a specific object
     *
     * @param oossFolder
     * @param fileName
     * @return
     */
    boolean deleteObject(String oossFolder, String fileName);
}

**LogStoryFactory.java**

package com.optum.pure.logstore.factory;

import com.optum.pure.common.RestElasticsearchClient;
import com.optum.pure.logstore.LogStore;
import com.optum.pure.logstore.impl.ESLogStore;

/**
 * Factory class for Log store
 *
 * @author Dwarakesh T P
 */
public class LogStoreFactory {
    private static LogStore logStore;

    private LogStoreFactory() {
    }

    public static synchronized LogStore getLogStore() {
        if (logStore == null)
            logStore = new ESLogStore(RestElasticsearchClient.getClient());
        return logStore;
    }
}

**ESLogStory.java**

package com.optum.pure.logstore.impl;

import com.google.gson.Gson;
import com.optum.pure.common.ConfigurationManager;
import com.optum.pure.logstore.LogStore;
import com.optum.pure.model.requestobjects.common.LogRecord;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.xcontent.XContentType;

import java.io.IOException;

/**
 * Implementation class for Elasticsearch Log store
 *
 * @author Dwarakesh T P
 */

public class ESLogStore implements LogStore {

    private static final Logger LOG = LogManager.getLogger(ESLogStore.class);
    private static final String ES_LOG_STORE_INDEX = ConfigurationManager.get("ES_LOG_STORE_INDEX");
    private RestHighLevelClient client;

    public ESLogStore(RestHighLevelClient client) {
        this.client = client;
    }

    @Override
    public void insertLogRecord(LogRecord logRecord) throws IOException {
        try {
            client.index(new IndexRequest(ES_LOG_STORE_INDEX).source(new Gson()
                    .toJson(logRecord), XContentType.JSON), RequestOptions.DEFAULT);
        } catch (IOException e) {
            LOG.error("Failed to insert log record for trackingId {} in LogStore",
                    logRecord.getTrackingId());
            throw e;
        }
    }
}

**LogStore.java**

package com.optum.pure.logstore;

import com.optum.pure.model.requestobjects.common.LogRecord;

import java.io.IOException;

/**
 * Interface for LogStore
 *
 * @author Dwarakesh T P
 */

public interface LogStore {

    /**
     * Method to insert a LogRecord to LogStore.
     */
    void insertLogRecord(LogRecord logRecord) throws IOException;
}
**== Model**
**Data.java**

package com.optum.pure.model.dto.common;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.Map;

@Getter
@Setter
@ToString
public class Data {

    @JsonIgnore
    private Map<String, Integer> timeMetrics;
    private Rx rx;
    private Medical medical;

    public Data() {
        rx = new Rx();
        medical = new Medical();
    }
}
==
MedClaimDto.java
package com.optum.pure.model.dto.common;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import com.optum.pure.model.entity.IcdDiagnosisCodesItem;
import com.optum.pure.model.entity.ServiceProcedureItem;
import lombok.Getter;
import lombok.ToString;
import lombok.extern.log4j.Log4j2;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Getter
@ToString
@Log4j2
@JsonInclude(JsonInclude.Include.NON_NULL)
public class MedClaimDto {
    @JsonIgnore
    private static final List<String> exclusionList = Arrays.asList("null", "NONE", "NO NDC");
    private String providerSpecialtyDescription;
    private String providerNpi;
    private String providerSpecialtyCode;
    private String adjudicationFlag;
    private String updateDate;
    private String serviceDate;
    private List<IcdDiagnosisCodesItem> icdDiagnosisCodes;
    private String ndcCodeDescription;
    private String claimType;
    private String ndcCode;
    private List<ServiceProcedureItem> serviceProcedures;
    private String claimId;
    private String icdCodeType;
    private String claimStatus;

    public List<String> getIcdDiagnosisCodes() {
        if (icdDiagnosisCodes == null)
            return null;
        List<String> items = new ArrayList<>();
        for (IcdDiagnosisCodesItem icdDiagnosisCodesItem : icdDiagnosisCodes) {
            items.add(icdDiagnosisCodesItem.getIcdDiagnosisCode());
        }
        return Utils.listFieldValidator(items);
    }

    public void setIcdDiagnosisCodes(List<IcdDiagnosisCodesItem> icdDiagnosisCodes) {
        this.icdDiagnosisCodes = Utils.listFieldValidator(icdDiagnosisCodes);
    }

    public void setIcdCodeType(String icdCodeType) {
        this.icdCodeType = Utils.stringFieldValidator(icdCodeType);
    }

    public void setClaimStatus(String claimStatus) {
        this.claimStatus = Utils.stringFieldValidator(claimStatus);
    }

    public void setAdjudicationFlag(String adjudicationFlag) {
        this.adjudicationFlag = Utils.stringFieldValidator(adjudicationFlag);
    }

    public void setClaimId(String claimId) {
        this.claimId = Utils.stringFieldValidator(claimId);
    }

    public void setProviderSpecialtyDescription(String providerSpecialtyDescription) {
        this.providerSpecialtyDescription = Utils.stringFieldValidator(providerSpecialtyDescription);
    }

    public void setUpdateDate(String updateDate) {
        this.updateDate = Utils.stringFieldValidator(updateDate);
    }

    public void setServiceDate(String serviceDate) {
        this.serviceDate = Utils.stringFieldValidator(serviceDate);
    }

    public void setNdcCode(String ndcCode) {
        this.ndcCode = Utils.stringFieldValidator(ndcCode);
    }

    public void setNdcCodeDescription(String ndcCodeDescription) {
        if (ndcCodeDescription == null || exclusionList.stream().anyMatch(ndcCodeDescription::equalsIgnoreCase)
                || ndcCodeDescription.isEmpty()) {
            this.ndcCodeDescription = null;
        } else {
            this.ndcCodeDescription = ndcCodeDescription;
        }
    }

    public void setClaimType(String claimType) {
        this.claimType = Utils.stringFieldValidator(claimType);
    }

    public void setServiceProcedures(List<ServiceProcedureItem> serviceProcedures) {
        this.serviceProcedures = Utils.listFieldValidator(serviceProcedures);
    }

    public void setProviderNpi(String providerNpi) {
        this.providerNpi = Utils.stringFieldValidator(providerNpi);
    }

    public void setProviderSpecialtyCode(String providerSpecialtyCode) {
        this.providerSpecialtyCode = Utils.stringFieldValidator(providerSpecialtyCode);
    }
}
===
**MedEligibilityDto.java**

package com.optum.pure.model.dto.common;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.Getter;
import lombok.ToString;

@Getter
@ToString
@JsonInclude(JsonInclude.Include.NON_NULL)
public class MedEligibilityDto {
    private String updateDate;
    private String endDate;
    private String healthPlanIdentifier;
    private String startDate;


    public void setUpdateDate(String updateDate) {
        this.updateDate = Utils.stringFieldValidator(updateDate);
    }

    public void setEndDate(String endDate) {
        this.endDate = Utils.stringFieldValidator(endDate);
    }

    public void setHealthPlanIdentifier(String healthPlanIdentifier) {
        this.healthPlanIdentifier = Utils.stringFieldValidator(healthPlanIdentifier);
    }

    public void setStartDate(String startDate) {
        this.startDate = Utils.stringFieldValidator(startDate);
    }
}

**Medical.java**
package com.optum.pure.model.dto.common;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@ToString
public class Medical {

    private List<MedEligibilityDto> eligibilities;
    private List<MedClaimDto> claims;

    public Medical() {
        eligibilities = new ArrayList<>();
        claims = new ArrayList<>();
    }
}

**Rx.java**

package com.optum.pure.model.dto.common;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@ToString
public class Rx {

    private List<RxEligibilityDto> eligibilities;
    private List<RxClaimDto> claims;

    public Rx() {
        eligibilities = new ArrayList<>();
        claims = new ArrayList<>();
    }
}

**RxClaimDto.java**
package com.optum.pure.model.dto.common;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.Getter;
import lombok.ToString;

@Getter
@ToString
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RxClaimDto {
    private String pharmacyId;
    private String drugCode;
    private String daysSupply;
    private String prescriptionNumber;
    private String quantityFilled;
    private String fillDate;
    private String prescribingProviderId;
    private String claimId;
    private String sequenceNumber;
    private String claimStatus;

    public void setClaimStatus(String claimStatus) {
        this.claimStatus = Utils.stringFieldValidator(claimStatus);
    }

    public void setClaimId(String claimId) {
        this.claimId = Utils.stringFieldValidator(claimId);
    }

    public void setSequenceNumber(String sequenceNumber) {
        this.sequenceNumber = Utils.stringFieldValidator(sequenceNumber);
    }

    public void setPharmacyId(String pharmacyId) {
        this.pharmacyId = Utils.stringFieldValidator(pharmacyId);
    }

    public void setDrugCode(String drugCode) {
        this.drugCode = Utils.stringFieldValidator(drugCode);
    }

    public void setDaysSupply(String daysSupply) {
        this.daysSupply = Utils.stringFieldValidator(daysSupply);
    }

    public void setPrescriptionNumber(String prescriptionNumber) {
        this.prescriptionNumber = Utils.stringFieldValidator(prescriptionNumber);
    }

    public void setQuantityFilled(String quantityFilled) {
        this.quantityFilled = Utils.stringFieldValidator(quantityFilled);
    }

    public void setFillDate(String fillDate) {
        this.fillDate = Utils.stringFieldValidator(fillDate);
    }

    public void setPrescribingProviderId(String prescribingProviderId) {
        this.prescribingProviderId = Utils.stringFieldValidator(prescribingProviderId);
    }
}

 **RxEligibilityDto.java**
package com.optum.pure.model.dto.common;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.Getter;
import lombok.ToString;

@Getter
@ToString
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RxEligibilityDto {
    private String healthPlanAccountIdentifier;
    private String endDate;
    private String healthPlanIdentifier;
    private String startDate;

    public void setHealthPlanAccountIdentifier(String healthPlanAccountIdentifier) {
        this.healthPlanAccountIdentifier = Utils.stringFieldValidator(healthPlanAccountIdentifier);
    }

    public void setEndDate(String endDate) {
        this.endDate = Utils.stringFieldValidator(endDate);
    }

    public void setHealthPlanIdentifier(String healthPlanIdentifier) {
        this.healthPlanIdentifier = Utils.stringFieldValidator(healthPlanIdentifier);
    }

    public void setStartDate(String startDate) {
        this.startDate = Utils.stringFieldValidator(startDate);
    }
}

**===V1**
**DeIdentifiedTokensV1.java**

package com.optum.pure.model.dto.v1;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.optum.pure.model.dto.common.Data;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
public class DeIdentifiedTokensV1 {

    private String token;
    @JsonIgnore
    private String tokenType;
    private Data data;

    public DeIdentifiedTokensV1() {
        data = new Data();
    }
}

**ResponseV1.java**
package com.optum.pure.model.dto.v1;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
public class ResponseV1 {

    private String trackingId;
    private String tokenType;
    private List<DeIdentifiedTokensV1> result;

    public ResponseV1(String trackingId, String tokenType) {
        this.trackingId = trackingId;
        this.tokenType = tokenType;
        result = new ArrayList<>();
    }
}

**==V2**
**DeIdentifiedTokensV2.java**
package com.optum.pure.model.dto.v2;

import com.optum.pure.model.dto.common.Data;
import com.optum.pure.model.requestobjects.v2.TokenTuple;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class DeIdentifiedTokensV2 {

    private TokenTuple tokenTuple;
    private Data data;

    public DeIdentifiedTokensV2() {
        data = new Data();
    }
}

**ResponseV2.java**
package com.optum.pure.model.dto.v2;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
public class ResponseV2 {

    private String trackingId;
    private List<DeIdentifiedTokensV2> result;

    public ResponseV2(String trackingId) {
        this.trackingId = trackingId;
        result = new ArrayList<>();
    }
}

**==Entity**
**IcdDiagnosisCodesItem.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Setter
@ToString
@NoArgsConstructor
public class IcdDiagnosisCodesItem {

    private String icdDiagnosisCode;
    private String icdDiagnosisDecimalCode;
    private String icdDiagnosisCodeDescription;

    public String getIcdDiagnosisCode() {
        return Utils.stringFieldValidator(icdDiagnosisCode);
    }

    public String getIcdDiagnosisDecimalCode() {
        return Utils.stringFieldValidator(icdDiagnosisDecimalCode);
    }

    public String getIcdDiagnosisCodeDescription() {
        return Utils.stringFieldValidator(icdDiagnosisCodeDescription);
    }
}

**MedClaim.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Getter
@Setter
@ToString
@NoArgsConstructor
public class MedClaim {

    private String recordId;
    private String city;
    private String memberIdentifier;
    private String stateCode;
    private String zip;
    private String dateOfBirth;
    private String gender;
    private String claimStatus;
    private String adjudicationFlag;
    private String claimId;
    private String providerZip;
    private String providerCity;
    private String providerSpecialtyDescription;
    private String updateDate;
    private String typeOfAdmissionDescription;
    private String sourceOfAdmissionDescription;
    private String serviceDate;
    private String drgCode;
    private String drgCodeDescription;
    private String healthPlanIdentifier;
    private String dischargeStatusCode;
    private String procedureCodeType;
    private List<IcdDiagnosisCodesItem> icdDiagnosisCodes;
    private String typeOfAdmission;
    private String ndcCodeDescription;
    private String claimType;
    private String sourceOfAdmission;
    private String typeOfBill;
    private String providerName;
    private String ndcCode;
    private String drgGrouper;
    private List<ServiceProcedureItem> serviceProcedures;
    private String providerLastName;
    private String providerStateCode;
    private String providerNpi;
    private List<ProcedureCodesItem> procedureCodes;
    private String dischargeStatusCodeDescription;
    private String admittingDiagnosisCode;
    private String providerSpecialtyCode;
    private String servicePostDate;
    private String providerFirstName;
    private String icdCodeType;
    private String providerAddress2;
    private String providerAddress1;
}

**MedClaim.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Getter
@Setter
@ToString
@NoArgsConstructor
public class MedClaim {

    private String recordId;
    private String city;
    private String memberIdentifier;
    private String stateCode;
    private String zip;
    private String dateOfBirth;
    private String gender;
    private String claimStatus;
    private String adjudicationFlag;
    private String claimId;
    private String providerZip;
    private String providerCity;
    private String providerSpecialtyDescription;
    private String updateDate;
    private String typeOfAdmissionDescription;
    private String sourceOfAdmissionDescription;
    private String serviceDate;
    private String drgCode;
    private String drgCodeDescription;
    private String healthPlanIdentifier;
    private String dischargeStatusCode;
    private String procedureCodeType;
    private List<IcdDiagnosisCodesItem> icdDiagnosisCodes;
    private String typeOfAdmission;
    private String ndcCodeDescription;
    private String claimType;
    private String sourceOfAdmission;
    private String typeOfBill;
    private String providerName;
    private String ndcCode;
    private String drgGrouper;
    private List<ServiceProcedureItem> serviceProcedures;
    private String providerLastName;
    private String providerStateCode;
    private String providerNpi;
    private List<ProcedureCodesItem> procedureCodes;
    private String dischargeStatusCodeDescription;
    private String admittingDiagnosisCode;
    private String providerSpecialtyCode;
    private String servicePostDate;
    private String providerFirstName;
    private String icdCodeType;
    private String providerAddress2;
    private String providerAddress1;
}

**MedEligibility.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Getter
@Setter
@ToString
@NoArgsConstructor
public class MedEligibility {

    private String stateCode;
    private String recordId;
    private String dateOfBirth;
    private String zipCode;
    private String memberIdentifier;
    private String gender;
    private String updateDate;
    private String endDate;
    private String healthPlanIdentifier;
    private String startDate;
}

**ProcedureCodeModifiersItem.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Setter
@ToString
@NoArgsConstructor
public class ProcedureCodeModifiersItem {
    private String procedureCodeModifier;
    private String procedureCodeModifierDescription;

    public String getProcedureCodeModifier() {
        return Utils.stringFieldValidator(procedureCodeModifier);
    }

    public String getProcedureCodeModifierDescription() {
        return Utils.stringFieldValidator(procedureCodeModifierDescription);
    }
}

**ProcedureCodesItem.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Setter
@ToString
@NoArgsConstructor
public class ProcedureCodesItem {

    private String procedureCode;
    private String procedureCodeDescription;

    public String getProcedureCode() {
        return Utils.stringFieldValidator(procedureCode);
    }

    public String getProcedureCodeDescription() {
        return Utils.stringFieldValidator(procedureCodeDescription);
    }
}

**RxClaim.java**

package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonAlias;
import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Getter
@Setter
@ToString
@NoArgsConstructor
public class RxClaim {

    private String cagm;
    private String memberIdentifier;
    private String status;
    private String recordId;
    private String claimStatus;
    private String claimId;
    private String sequenceNumber;
    private String firstName;
    private String middleName;
    private String lastName;
    private String dateOfBirth;
    private String gender;
    private String address1;
    private String address2;
    private String city;
    private String stateCode;
    private String zipCode;
    private String snapshotTime;
    private String galaxyIdentifier;
    private String addressType;
    private String pharmacyId;
    private String drugCode;
    private String healthPlanIdentifier;
    private String daysSupply;
    private String prescriptionNumber;
    @JsonAlias("prescriberSpecialityDescription")
    private String prescriberSpecialtyDescription;
    private String quantityFilled;
    private String fillDate;
    private String drugCodeType;
    private String drugStrength;
    private String drugCarrier;
    @JsonAlias("prescriberSpecialityCode")
    private String prescriberSpecialtyCode;
    private String refillNumber;
    private String drugName;
    private String prescribingProviderId;
    private String totalRefills;
    private String providerName;
}

**RxEligibility.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Getter
@Setter
@ToString
@NoArgsConstructor
public class RxEligibility {

    private String recordId;
    private String cagm;
    private String status;
    private String memberIdentifier;
    private String firstName;
    private String middleName;
    private String lastName;
    private String gender;
    private String dateOfBirth;
    private String address1;
    private String address2;
    private String city;
    private String stateCode;
    private String zipCode;
    private String snapshotTime;
    private String healthPlanAccountIdentifier;
    private String endDate;
    private String healthPlanIdentifier;
    private String startDate;
}

**ServiceDiagnosesItem.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Setter
@ToString
@NoArgsConstructor
public class ServiceDiagnosesItem {

    private String diagnosisCode;
    private String diagnosisCodeDescription;

    public String getDiagnosisCode() {
        return Utils.stringFieldValidator(diagnosisCode);
    }

    public String getDiagnosisCodeDescription() {
        return Utils.stringFieldValidator(diagnosisCodeDescription);
    }

}

**ServiceProcedureItem.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.optum.pure.common.Utils;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

@JsonInclude(JsonInclude.Include.NON_NULL)
@Setter
@ToString
@NoArgsConstructor
public class ServiceProcedureItem {

    private List<ServiceDiagnosesItem> serviceDiagnoses;
    private String typeOfServiceCode;
    private String revenueCodeDescription;
    private String procedureCode;
    private String procedureCodeType;
    private String quantityOfServices;
    private List<ProcedureCodeModifiersItem> procedureCodeModifiers;
    private String toDate;
    private String placeOfService;
    @JsonIgnore
    private String typeOfServiceDescription;
    private String fromDate;
    @JsonIgnore
    private String procedureCodeDescription;
    private String lineNumber;
    @JsonIgnore
    private String placeOfServiceDescription;
    private String revenueCode;

    public List<String> getServiceDiagnoses() {
        if (serviceDiagnoses == null)
            return null;
        List<String> items = new ArrayList<>();
        for (ServiceDiagnosesItem serviceDiagnosesItem : serviceDiagnoses) {
            items.add(serviceDiagnosesItem.getDiagnosisCode());
        }
        return Utils.listFieldValidator(items);
    }

    public String getTypeOfServiceCode() {
        return Utils.stringFieldValidator(typeOfServiceCode);
    }

    public String getRevenueCodeDescription() {
        return Utils.stringFieldValidator(revenueCodeDescription);
    }

    public String getProcedureCode() {
        return Utils.stringFieldValidator(procedureCode);
    }

    public String getProcedureCodeType() {
        return Utils.stringFieldValidator(procedureCodeType);
    }

    public String getQuantityOfServices() {
        return Utils.stringFieldValidator(quantityOfServices);
    }

    public List<String> getProcedureCodeModifiers() {
        if (procedureCodeModifiers == null)
            return null;
        List<String> items = new ArrayList<>();
        for (ProcedureCodeModifiersItem procedureCodeModifiersItem : procedureCodeModifiers) {
            items.add(procedureCodeModifiersItem.getProcedureCodeModifier());
        }
        return Utils.listFieldValidator(items);
    }

    public String getToDate() {
        return Utils.stringFieldValidator(toDate);
    }

    public String getPlaceOfService() {
        return Utils.stringFieldValidator(placeOfService);
    }

    public String getTypeOfServiceDescription() {
        return Utils.stringFieldValidator(typeOfServiceDescription);
    }

    public String getFromDate() {
        return Utils.stringFieldValidator(fromDate);
    }

    public String getProcedureCodeDescription() {
        return Utils.stringFieldValidator(procedureCodeDescription);
    }

    public String getLineNumber() {
        return Utils.stringFieldValidator(lineNumber);
    }

    public String getPlaceOfServiceDescription() {
        return Utils.stringFieldValidator(placeOfServiceDescription);
    }

    public String getRevenueCode() {
        return Utils.stringFieldValidator(revenueCode);
    }
}

**TrackingStatus.java**
package com.optum.pure.model.entity;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@AllArgsConstructor
@ToString
public class TrackingStatus {

    @JsonInclude(JsonInclude.Include.NON_NULL)
    private final String trackingId;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String status;
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String errorDescription;

    public TrackingStatus(String trackingId, String status) {
        this.trackingId = trackingId;
        this.status = status;
    }

    public TrackingStatus(String trackingId) {
        this.trackingId = trackingId;
    }

}
**==Notification**
**Notification.java**
package com.optum.pure.model.notification;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Notification {
    private String trackingId;
    private String version;
    private String inputArtifactUri;
}
**==RequestObject**
**LogRecord.java**

package com.optum.pure.model.requestobjects.common;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
@ToString
public class LogRecord {
    private String trackingId;
    private String correlationId;
    private String callerId;
    private String serviceName;
    private String status;
    private String timeStamp;
    private long timeTakenMs;
}

**ProcessingMetrics.java**

package com.optum.pure.model.requestobjects.common;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class ProcessingMetrics {
    int numberOfTokens;
}

**RecordCount.java**
package com.optum.pure.model.requestobjects.common;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
public class RecordCount {
    int eligibilityCount;
    int claimsCount;
}

**TrackingRecord.java**
package com.optum.pure.model.requestobjects.common;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.Map;

@Getter
@Setter
@ToString
@NoArgsConstructor
public class TrackingRecord {

    private String trackingId;
    private String status;
    private String errorDescription;
    private String inputArtifactUri;
    private String outputArtifactUri;
    private String receivedTimestamp;
    private String processingStartedTimestamp;
    private String processingCompletedTimestamp;
    private String callerId;
    private String version;
    private String requestUri;
    private String producerUri;
    private String consumerUri;

    //Time metrics
    private long timeToWriteInputToFileStore;
    private long timeToInsertTrackingRecord;
    private long timeToEmitNotification;
    private String notificationEmitTimestamp;
    private String notificationReceivedTimestamp;
    private long timeToFetchAltIds;
    private long timeToReadInputFromFileStore;
    private long timeToFetchClaimsAndEligibilities;
    private long timeToWriteOutputToFileStore;
    private long totalTimeToProcessNotification;
    private long timeToUpdateStatusFromNotYetStarted;
    private long timeToUpdateStatusFromInProgress;
    private long timeToReadOutputFromFileStore;
    private Map<String, Integer> timeMetrics;

    //Record count
    private int tokenCountReceived;
    private int tokenCountMatched;
    private int tokenCountMatchedWithData;
    private int rxClaimsCount;
    private int rxEligCount;
    private int medClaimsCount;
    private int medEligCount;

    private TrackingRecord(Builder builder) {
        trackingId = builder.trackingId;
        tokenCountReceived = builder.tokenCountReceived;
        status = builder.status;
        inputArtifactUri = builder.inputArtifactUri;
        receivedTimestamp = builder.receivedTimestamp;
        callerId = builder.callerId;
        version = builder.version;
        requestUri = builder.requestUri;
        producerUri = builder.producerUri;
        timeToWriteInputToFileStore = builder.timeToWriteInputToFileStore;
    }

    public static class Builder {
        private final String trackingId;
        private String status;
        private String inputArtifactUri;
        private String receivedTimestamp;
        private String callerId;
        private String version;
        private String requestUri;
        private String producerUri;
        private long timeToWriteInputToFileStore;
        private int tokenCountReceived;

        public Builder(String trackingId) {
            this.trackingId = trackingId;
        }

        public Builder setStatus(String value) {
            status = value;
            return this;
        }

        public Builder setTokenCountReceived(int value) {
            tokenCountReceived = value;
            return this;
        }

        public Builder setInputArtifactUri(String value) {
            inputArtifactUri = value;
            return this;
        }

        public Builder setReceivedTimestamp(String value) {
            receivedTimestamp = value;
            return this;
        }

        public Builder setCallerId(String value) {
            callerId = value;
            return this;
        }

        public Builder setVersion(String value) {
            version = value;
            return this;
        }

        public Builder setRequestUri(String value) {
            requestUri = value;
            return this;
        }

        public Builder setProducerUri(String value) {
            producerUri = value;
            return this;
        }

        public Builder setTimeToWriteInputToFileStore(long value) {
            timeToWriteInputToFileStore = value;
            return this;
        }

        public TrackingRecord build() {
            return new TrackingRecord(this);
        }
    }
}
**==V1**
**PostTokensV1.java**
package com.optum.pure.model.requestobjects.v1;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@Getter
@Setter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class PostTokensV1 {
    private String tokenType;
    private List<String> deIdentifiedTokens;
}

**==V2**
**PostTokensV2.java**
package com.optum.pure.model.requestobjects.v2;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@Getter
@Setter
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class PostTokensV2 {
    List<TokenTuple> deIdentifiedTokenTuples;
}

**TokenTuple.java**

package com.optum.pure.model.requestobjects.v2;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@ToString
@EqualsAndHashCode
public class TokenTuple {
    @NonNull
    String tokenType1;
    @NonNull
    String tokenType2;
}

**==TokenObject**
**AlternateIdentifierObject.java**
package com.optum.pure.model.tokenobjects;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@NoArgsConstructor
@ToString
public class AlternateIdentifierObject {

    private String alternateIdentifier;
    private String alternateIdentifierType;
    private String alternateIdentifierSource;
}


**Tokens.java**
package com.optum.pure.model.tokenobjects;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@ToString
public class Tokens {

    private List<String> tokenType1;
    private List<String> tokenType2;
    private List<String> tokenType3;
    private List<String> tokenType4;
    private List<String> tokenType6;

    public List<String> get(String tokenType) {
        List<String> tokenList;

        switch (tokenType) {
            case "tokenType1":
                tokenList = tokenType1;
                break;
            case "tokenType2":
                tokenList = tokenType2;
                break;
            case "tokenType3":
                tokenList = tokenType3;
                break;
            case "tokenType4":
                tokenList = tokenType4;
                break;
            case "tokenType6":
                tokenList = tokenType6;
                break;
            default:
                return new ArrayList<>();
        }

        return tokenList;
    }
}

**TokenStoreObject.java**
package com.optum.pure.model.tokenobjects;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@ToString
public class TokenStoreObject {

    private String status;
    private List<AlternateIdentifierObject> alternateIdentifiers;
    private Tokens tokenList;
    private String recordId;
    private String loadTimeStamp;
}

==Trackingstore
TrackingStoreFactory.java
package com.optum.pure.trackingstore.factory;

import com.optum.pure.common.RestElasticsearchClient;
import com.optum.pure.trackingstore.TrackingStore;
import com.optum.pure.trackingstore.impl.ESTrackingStore;

/**
 * Factory class for Tracking store
 *
 * @author Dwarakesh T P
 */
public class TrackingStoreFactory {
    private static TrackingStore trackingStore;

    public static synchronized TrackingStore getTrackingStore() {
        if (trackingStore == null)
            trackingStore = new ESTrackingStore(RestElasticsearchClient.getClient());
        return trackingStore;
    }
}
**==Impl**
**ESTrackingStore.java**
package com.optum.pure.trackingstore.impl;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.optum.pure.common.ConfigurationManager;
import com.optum.pure.model.requestobjects.common.TrackingRecord;
import com.optum.pure.model.entity.TrackingStatus;
import com.optum.pure.trackingstore.TrackingStore;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.xcontent.XContentBuilder;
import org.elasticsearch.xcontent.XContentType;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.builder.SearchSourceBuilder;

import java.io.IOException;
import java.util.List;

import static org.elasticsearch.xcontent.XContentFactory.jsonBuilder;

/**
 * This implementation of {@link TrackingStore} uses elasticsearch to store and fetch the tracking records.
 *
 * @author Nandu
 */

public class ESTrackingStore implements TrackingStore {

    private static final Logger LOG = LogManager.getLogger(ESTrackingStore.class);
    private static final String ES_TRACKING_STORE_INDEX = ConfigurationManager.get("ES_TRACKING_STORE_INDEX");
    private static final int RETRY_COUNT = 3;
    private final ObjectMapper objectMapper = new ObjectMapper();
    private RestHighLevelClient client;

    public ESTrackingStore(RestHighLevelClient client) {
        this.client = client;
    }

    @Override
    public TrackingStatus getTrackingStatus(String trackingId) throws IOException {
        return new TrackingStatus(trackingId, getTrackingRecord(trackingId).getStatus());
    }

    @Override
    public TrackingRecord getTrackingRecord(String trackingId) throws IOException {
        TrackingRecord trackingRecord = new TrackingRecord();
        SearchResponse response;

        try {
            response = client.search(getSearchRequest(ES_TRACKING_STORE_INDEX, getSearchByTrackingIdQuery(trackingId)),
                    RequestOptions.DEFAULT);
        } catch (IOException e) {
            LOG.error("Failed to fetch tracking Record for trackingId {} from TrackingStore", trackingId);
            throw e;
        }

        if (response.getHits().getHits().length > 0) {
            try {
                trackingRecord = objectMapper.readValue(response.getHits().getAt(0).getSourceAsString(),
                        TrackingRecord.class);
            } catch (IOException e) {
                LOG.error("Failed to parse tracking Record for trackingId {}", trackingId);
                throw e;
            }
        }
        return trackingRecord;
    }

    private BoolQueryBuilder getSearchByTrackingIdQuery(String trackingId) {
        BoolQueryBuilder builder = QueryBuilders.boolQuery();
        builder.filter(QueryBuilders.termQuery("trackingId", trackingId));
        return builder;
    }

    private SearchRequest getSearchRequest(String index, BoolQueryBuilder query) {
        SearchRequest searchRequest = new SearchRequest();
        searchRequest.indices(index).source(new SearchSourceBuilder().query(query).fetchSource(null));
        return searchRequest;
    }

    public void insertTrackingRecord(TrackingRecord trackingRecord) throws IOException {
        try {
            client.index(new IndexRequest(ES_TRACKING_STORE_INDEX)
                    .id(trackingRecord.getTrackingId()).source(new Gson()
                            .toJson(trackingRecord), XContentType.JSON), RequestOptions.DEFAULT);
        } catch (IOException e) {
            LOG.error("Failed to insert tracking Record for trackingId {} in TrackingStore",
                    trackingRecord.getTrackingId());
            throw e;
        }
    }

    @Override
    public void updateRecord(String trackingId, List<String> fields, List<?> values) throws IOException {
        UpdateRequest updateRequest = new UpdateRequest();
        updateRequest.retryOnConflict(RETRY_COUNT);
        XContentBuilder doc = null;
        try {
            doc = jsonBuilder().startObject();
            for (int index = 0; index < fields.size(); index++) {
                doc.field(fields.get(index), values.get(index));
            }
            doc.endObject();
        } catch (IOException e) {
            LOG.error("Error while creating multi update Request for TrackingRecord for trackingId {}", trackingId);
            throw e;
        }
        updateRequest.index(ES_TRACKING_STORE_INDEX)
                .id(trackingId).doc(doc);
        try {
            client.update(updateRequest, RequestOptions.DEFAULT);
            LOG.debug("Update Record successful for trackingId-{}", trackingId);
        } catch (IOException e) {
            LOG.error("Error while updating trackingRecord for trackingId {}", trackingId);
            throw e;
        }
    }
}

**TrackingStore.java**
package com.optum.pure.trackingstore;

import com.optum.pure.model.requestobjects.common.TrackingRecord;
import com.optum.pure.model.entity.TrackingStatus;

import java.io.IOException;
import java.util.List;

/**
 * Interface for TrackingStore
 *
 * @author Nandu
 */
public interface TrackingStore {

    /**
     * Method to get Tracking Status from Tracking store based on TrackingId.
     *
     * @param trackingId - The trackingId for which record is to be fetched.
     * @return - TrackingStatus object formed using TrackingRecord object fetched from Tracking Store.
     * @throws IOException - Exception while querying Tracking Store.
     */
    TrackingStatus getTrackingStatus(String trackingId) throws IOException;

    /**
     * Method to return Tracking Record from Tracking store based on Tracking id
     *
     * @param trackingId
     * @return
     * @throws IOException
     */
    TrackingRecord getTrackingRecord(String trackingId) throws IOException;

    /**
     * Method to insert a TrackingRecord to TrackingStore.
     *
     * @param trackingRecord
     * @throws IOException
     */
    void insertTrackingRecord(TrackingRecord trackingRecord)
            throws IOException;

    /**
     * Method to update a list of fields in TrackingStore.
     *
     * @param trackingId
     * @param fields
     * @param values
     * @throws IOException
     */
    void updateRecord(String trackingId, List<String> fields, List<?> values) throws IOException;
}

**==Test**
**common**
**ConfigurationManagerTest.java**
package com.optum.pure.common;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import java.lang.reflect.Field;
import java.util.Properties;

/**
 * JUnit tests for ConfigurationManager.java
 *
 * @author Dwarakesh T P
 */

@RunWith(PowerMockRunner.class)
@PrepareForTest(ConfigurationManager.class)
@PowerMockIgnore("javax.management.*")
public class ConfigurationManagerTest {

    Properties props;

    @Before
    public void setUp() {
        props = PowerMockito.mock(Properties.class);
    }

    @Test
    public void getTest() throws IllegalAccessException {
        Field field = PowerMockito.field(ConfigurationManager.class, "props");
        field.set(ConfigurationManager.class, props);
        PowerMockito.when(props.getProperty(Mockito.anyString())).thenReturn("test");
        String value = ConfigurationManager.get("key");
        Assert.assertEquals("test", value);
    }
}

**RestElasticSearchClientTest.java**

package com.optum.pure.common;

import org.elasticsearch.client.RestHighLevelClient;
import org.junit.Assert;
import org.junit.Test;

/**
 * JUnit tests for RestElasticSearchClient.java
 *
 * @author Dwarakesh T P
 */

public class RestElasticSearchClientTest {

    @Test
    public void getClientTestAssertNotNull() {
        RestHighLevelClient client = RestElasticsearchClient.getClient();
        Assert.assertNotNull(client);
    }

    @Test
    public void getClientTestAssertEquals() {
        RestHighLevelClient client1 = RestElasticsearchClient.getClient();
        RestHighLevelClient client2 = RestElasticsearchClient.getClient();
        Assert.assertEquals(client1, client2);
    }
}

**StatusEnumTest.java**

package com.optum.pure.common;

import org.junit.Assert;
import org.junit.Test;

public class StatusEnumTest {

    @Test
    public void enumTest() {
        Assert.assertEquals("COMPLETED_SUCCESSFULLY", StatusEnum.COMPLETED_SUCCESSFULLY.toString());
        Assert.assertEquals("IN_PROGRESS", StatusEnum.IN_PROGRESS.toString());
        Assert.assertEquals("NOT_YET_STARTED", StatusEnum.NOT_YET_STARTED.toString());
        Assert.assertEquals("ERRORED", StatusEnum.ERRORED.toString());
        Assert.assertEquals("INVALID", StatusEnum.INVALID.toString());
    }
}

**UtilsTest.java**

package com.optum.pure.common;

import org.junit.Assert;
import org.junit.Test;

/**
 * Junit Tests for common Utils.java
 *
 * @author Dwarakesh T P
 */

public class UtilsTest {

    @Test
    public void generateTrackingIdtest() {
        String trackingId = Utils.generateTrackingId();
        Assert.assertNotNull(trackingId);
    }

    @Test
    public void getCurrentDateTest() {
        String date = Utils.getCurrentDate();
        Assert.assertNotNull(date);
    }

    @Test
    public void getCurrentTimestampTest() {
        String timestamp = Utils.getCurrentTimestamp();
        Assert.assertNotNull(timestamp);
    }

    @Test
    public void getKafkaResourcePathTest() {
        String path = Utils.getKafkaResourcePath();
        Assert.assertNotNull(path);
    }

    @Test
    public void getNewInputArtifactUriTest() {
        String uri = Utils.getNewInputArtifactUri("12345");
        Assert.assertNotNull(uri);
    }

    @Test
    public void getNewOutputArtifactUriTest() {
        String uri = Utils.getNewOutputArtifactUri("12345");
        Assert.assertNotNull(uri);
    }
}

**==filestore**
**factory**
**FileStoreFactoryTest.java**
package com.optum.pure.filestore.factory;

import com.optum.pure.filestore.FileStore;
import org.junit.Assert;
import org.junit.Test;

/**
 * JUnit tests for FileStoreFactory.java
 *
 * @author Dwarakesh T P
 */

public class FileStoreFactoryTest {

    @Test
    public void getFileStoreNotNullTest() {
        FileStore fileStore = FileStoreFactory.getFileStore();
        Assert.assertNotNull(fileStore);
    }

    @Test
    public void getFileStoreEqualsTest() {
        FileStore fileStore1 = FileStoreFactory.getFileStore();
        FileStore fileStore2 = FileStoreFactory.getFileStore();
        Assert.assertEquals(fileStore1, fileStore2);
    }
}
**Impl**
**OOSSFileStoreTest.java**
package com.optum.pure.filestore.impl;

import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.model.ObjectMetadata;
import com.amazonaws.services.s3.model.PutObjectResult;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.services.s3.model.S3ObjectInputStream;
import com.amazonaws.services.s3.transfer.TransferManager;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.optum.pure.common.Utils;
import com.optum.pure.model.requestobjects.v1.PostTokensV1;
import mockit.Deencapsulation;
import mockit.Expectations;
import mockit.Mock;
import mockit.MockUp;
import mockit.Mocked;
import mockit.Tested;
import mockit.integration.junit4.JMockit;
import org.apache.commons.io.IOUtils;
import org.apache.http.client.methods.HttpRequestBase;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * JUnit Tests for OOSSFileStore.java
 *
 * @author Dwarakesh T P
 */

@RunWith(JMockit.class)
public class OOSSFileStoreTest {

    PutObjectResult putResult;
    PostTokensV1 postTokensV1;
    @Tested
    OOSSFileStore oossFileStore;
    @Mocked
    private AmazonS3 mockClient;
    @Mocked
    private S3Object s3Object;
    @Mocked
    private ObjectMapper objectMapper;
    @Mocked
    private TransferManager mockTransferManager;
    @Mocked
    private HttpRequestBase httpRequestBase;

    @Before
    public void setup() {

        final String tokenType = "token1";
        final List<String> deIdentifiedTokens = new ArrayList<>();
        deIdentifiedTokens.add("pure");
        deIdentifiedTokens.add("ohhl");
        deIdentifiedTokens.add("test");
        final String callerId = "Dev";
        postTokensV1 = new PostTokensV1(tokenType, deIdentifiedTokens);

        putResult = new PutObjectResult();
        putResult.setVersionId("1");

        mockS3Client();
    }

    @Test
    public void checkIfObjectPresentSuccessTest() {

        new Expectations() {
            {
                mockClient.doesObjectExist(anyString, anyString);
                result = true;
            }
        };
        boolean result = oossFileStore.checkIfObjectPresent(mockClient, "key");
        Assert.assertTrue(result);
    }

    @Test
    public void checkIfObjectPresentFailTest() {

        new Expectations() {
            {
                mockClient.doesObjectExist(anyString, anyString);
                result = false;
            }
        };
        boolean result = oossFileStore.checkIfObjectPresent(mockClient, "key");
        Assert.assertFalse(result);
    }

    @Test
    public void deleteObjectSuccessTest() {

        new Expectations() {
            {
                mockClient.deleteObject(anyString, anyString);
            }
        };
        boolean result = oossFileStore.deleteObject("test", "key");
        Assert.assertTrue(result);
    }

    @Test(expected = RuntimeException.class)
    public void deleteObjectFailTest() {

        new Expectations() {
            {
                mockClient.deleteObject(anyString, anyString);
                result = new RuntimeException("test");
            }
        };
        oossFileStore.deleteObject(null, null);
    }

    @Test
    public void writeObjectSuccessTest() throws Exception {

        oossFileStore.writeObject("test" + Utils.FILE_SEPARATOR + "test", postTokensV1, false);
        Assert.assertEquals("1", putResult.getVersionId());
    }

    @Test(expected = Exception.class)
    public void writeObjectFailTest() throws IOException, InterruptedException {
        new Expectations() {{
            Deencapsulation.setField(oossFileStore, "transferManager", mockTransferManager);

            mockTransferManager.upload(anyString, anyString, (InputStream) any, (ObjectMetadata) any);
            result = new Exception();
        }};
        oossFileStore.writeObject("test" + Utils.FILE_SEPARATOR + "test", postTokensV1, false);
    }

    @Test
    public void readObjectSuccessTest() throws Exception {

        new Expectations() {
            {
                mockClient.doesObjectExist(anyString, anyString);
                result = true;
                mockClient.getObject(anyString, anyString);
                result = s3Object;
                s3Object.getObjectContent();
                result = new S3ObjectInputStream(IOUtils.toInputStream("{\"tokenType\": \"tokenType1\", " +
                        "\"deIdentifiedTokens\": [\"test-token\"]}"), httpRequestBase);
            }
        };
        byte[] obj = oossFileStore.readObject("input" + Utils.FILE_SEPARATOR + "test.json");
        Object object = objectMapper.readValue(obj, PostTokensV1.class);
        Assert.assertTrue(object.getClass().toString().contains("PostTokensV1"));
    }

    @Test(expected = FileNotFoundException.class)
    public void readObjectFailTest1() throws IOException {
        new Expectations() {{
            mockClient.doesObjectExist(anyString, anyString);
            result = false;
        }};
        oossFileStore.readObject("test");
    }

    @Test(expected = Exception.class)
    public void readObjectFailTest2() throws IOException {
        new Expectations() {{
            mockClient.doesObjectExist(anyString, anyString);
            result = true;
            mockClient.getObject(anyString, anyString);
            result = new Exception();
        }};
        oossFileStore.readObject("test");
    }

    private void mockS3Client() {
        new MockUp<Utils>() {
            @Mock
            public AmazonS3 getS3client() {
                return mockClient;
            }
        };
    }
}

**logstore**
**factory**
**LogStoreFactoryTest.java**
package com.optum.pure.logstore.factory;

import com.optum.pure.logstore.LogStore;
import org.junit.Assert;
import org.junit.Test;

/**
 * Unit test for Log store factory class
 *
 * @author Dwarakesh T P
 */
public class LogStoreFactoryTest {
    @Test
    public void getTrackingStoreNotNullTest() {
        LogStore logStore = LogStoreFactory.getLogStore();
        Assert.assertNotNull(logStore);
    }

    @Test
    public void getTrackingStoreEqualsTest() {
        LogStore logStore1 = LogStoreFactory.getLogStore();
        LogStore logStore2 = LogStoreFactory.getLogStore();
        Assert.assertEquals(logStore1, logStore2);
    }
}

**impl**

**ESLogStoreTest.java**
package com.optum.pure.logstore.impl;

import com.optum.pure.logstore.LogStore;
import com.optum.pure.model.requestobjects.common.LogRecord;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import org.elasticsearch.common.io.stream.StreamInput;

import java.io.EOFException;
import java.io.IOException;

@RunWith(PowerMockRunner.class)
@PrepareForTest({com.optum.pure.logstore.impl.ESLogStore.class, RestHighLevelClient.class})
@PowerMockIgnore("javax.management.*")
public class ESLogStoreTest {
    private RestHighLevelClient mockClient;
    private LogStore logStore;
    private LogRecord logRecord;

    @Before
    public void setUp() {
        mockClient = PowerMockito.mock(RestHighLevelClient.class);
        logStore = new ESLogStore(mockClient);
        logRecord = new LogRecord();
        logRecord.setCallerId("test");
    }

    @Test
    public void insertLogRecordTest() throws IOException {
        PowerMockito.when(mockClient.index(Mockito.any(IndexRequest.class), Mockito.any(RequestOptions.class))).thenReturn(new IndexResponse(new StreamInput() {
            @Override
            public byte readByte() throws IOException {
                return 0;
            }

            @Override
            public void readBytes(byte[] b, int offset, int len) throws IOException {

            }

            @Override
            public void close() throws IOException {

            }

            @Override
            public int available() throws IOException {
                return 0;
            }

            @Override
            protected void ensureCanReadBytes(int length) throws EOFException {

            }

            @Override
            public int read() throws IOException {
                return 0;
            }
        }));
        logStore.insertLogRecord(logRecord);
    }
}

**Trackingstore**
**factory**
**TrackingStoreFactoryTest.java**
package com.optum.pure.trackingstore.factory;

import com.optum.pure.trackingstore.TrackingStore;
import org.junit.Assert;
import org.junit.Test;

/**
 * Unit test for Tracking store factory class
 *
 * @author Dwarakesh T P
 */
public class TrackingStoreFactoryTest {
    @Test
    public void getTrackingStoreNotNullTest() {
        TrackingStore trackingStore = TrackingStoreFactory.getTrackingStore();
        Assert.assertNotNull(trackingStore);
    }

    @Test
    public void TrackingStoreEqualsTest() {
        TrackingStore trackingStore1 = TrackingStoreFactory.getTrackingStore();
        TrackingStore trackingStore2 = TrackingStoreFactory.getTrackingStore();
        Assert.assertEquals(trackingStore1, trackingStore2);
    }
}
**==impl**
**ESTrackingStoreTest.java**
package com.optum.pure.trackingstore.impl;

import com.optum.pure.model.requestobjects.common.TrackingRecord;
import com.optum.pure.trackingstore.TrackingStore;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.SearchHits;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PowerMockIgnore;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

import java.io.EOFException;
import java.io.IOException;

@RunWith(PowerMockRunner.class)
@PrepareForTest({com.optum.pure.trackingstore.impl.ESTrackingStore.class, RestHighLevelClient.class, SearchResponse.class, SearchHits.class, SearchHit.class})
@PowerMockIgnore("javax.management.*")
public class ESTrackingStoreTest {

    private RestHighLevelClient mockClient;
    private TrackingStore mockTrackingStore;
    private SearchResponse mockSearchResponse;
    private SearchHits mockHits;
    private SearchHit mockHit;
    private SearchHit[] mockHitArray;
    private String responseString;
    private TrackingRecord trackingRecord;
    private TrackingStore trackingStore;

    @Before
    public void setup() {
        mockTrackingStore = PowerMockito.mock(com.optum.pure.trackingstore.impl.ESTrackingStore.class);
        mockClient = PowerMockito.mock(RestHighLevelClient.class);
        mockSearchResponse = PowerMockito.mock(SearchResponse.class);
        mockHits = PowerMockito.mock(SearchHits.class);
        mockHit = PowerMockito.mock(SearchHit.class);
        mockHitArray = new SearchHit[1];
        trackingRecord = new TrackingRecord();
        trackingRecord.setStatus("IN-PROGRESS");
        trackingRecord.setTrackingId("test");
        trackingRecord.setCallerId("test");
        trackingStore = new ESTrackingStore(mockClient);
        responseString = "{ \"trackingId\": \"test\", \"status\": \"IN-PROGRESS\", \"callerId\": \"test\" }";
    }

    @Test
    public void getTrackingStatusTest() throws IOException {
        PowerMockito.when(mockTrackingStore.getTrackingRecord("test")).thenReturn(trackingRecord);
        PowerMockito.when(mockTrackingStore.getTrackingStatus(Mockito.anyString())).thenCallRealMethod();
        mockTrackingStore.getTrackingStatus("test");
    }

    @Test
    public void getTrackingRecordTestSuccess() throws IOException {
        PowerMockito.when(mockClient.search(Mockito.any(SearchRequest.class), Mockito.any(RequestOptions.class))).thenReturn(mockSearchResponse);
        PowerMockito.when(mockSearchResponse.getHits()).thenReturn(mockHits);
        PowerMockito.when(mockHits.getHits()).thenReturn(mockHitArray);
        PowerMockito.when(mockHits.getAt(Mockito.anyInt())).thenReturn(mockHit);
        PowerMockito.when(mockHit.getSourceAsString()).thenReturn(responseString);
        TrackingRecord result = trackingStore.getTrackingRecord("test");
        Assert.assertEquals(result.toString(), trackingRecord.toString());
    }

    @Test(expected = IOException.class)
    public void getTrackingRecordTestSearchFail() throws IOException {
        PowerMockito.when(mockClient.search(Mockito.any(SearchRequest.class), Mockito.any(RequestOptions.class))).thenThrow(new IOException("test"));
        trackingStore.getTrackingRecord("test");
    }

    @Test(expected = IOException.class)
    public void getTrackingRecordTestParseFail() throws IOException {
        PowerMockito.when(mockClient.search(Mockito.any(SearchRequest.class), Mockito.any(RequestOptions.class))).thenReturn(mockSearchResponse);
        PowerMockito.when(mockSearchResponse.getHits()).thenReturn(mockHits);
        PowerMockito.when(mockHits.getHits()).thenReturn(mockHitArray);
        PowerMockito.when(mockHits.getAt(Mockito.anyInt())).thenReturn(mockHit);
        PowerMockito.when(mockHit.getSourceAsString()).thenReturn("{ \"Invalid-Field\": \"test\" }");
        trackingStore.getTrackingRecord("test");
    }

    @Test
    public void insertTrackingRecordTest() throws IOException {
        PowerMockito.when(mockClient.index(Mockito.any(IndexRequest.class), Mockito.any(RequestOptions.class))).thenReturn(new IndexResponse(new StreamInput() {
            @Override
            public byte readByte() throws IOException {
                return 0;
            }

            @Override
            public void readBytes(byte[] b, int offset, int len) throws IOException {

            }

            @Override
            public void close() throws IOException {

            }

            @Override
            public int available() throws IOException {
                return 0;
            }

            @Override
            protected void ensureCanReadBytes(int length) throws EOFException {

            }

            @Override
            public int read() throws IOException {
                return 0;
            }
        }));
        trackingStore.insertTrackingRecord(trackingRecord);
    }

    @Test(expected = IOException.class)
    public void insertTrackingRecordTestFail() throws IOException {
        PowerMockito.when(mockClient.index(Mockito.any(IndexRequest.class), Mockito.any(RequestOptions.class))).thenThrow(new IOException("test"));
        trackingStore.insertTrackingRecord(trackingRecord);
    }
}
